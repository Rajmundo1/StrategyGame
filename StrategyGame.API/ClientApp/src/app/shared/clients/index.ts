/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.0.0 (NJsonSchema v9.12.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class LoginClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    login(loginDto: LoginDto | null): Observable<TokenDto | null> {
        let url_ = this.baseUrl + "/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<TokenDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokenDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<TokenDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TokenDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenDto | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiAuthRegisterClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    register(registerDto: RegisterDto | null): Observable<TokenDto | null> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<TokenDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokenDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<TokenDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TokenDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenDto | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiAuthLogoutClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    logout(): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiBuildingBuildingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getBuildings(countyId: string): Observable<BuildingDto[] | null> {
        let url_ = this.baseUrl + "/api/Building/buildings/{countyId}";
        if (countyId === undefined || countyId === null)
            throw new Error("The parameter 'countyId' must be defined.");
        url_ = url_.replace("{countyId}", encodeURIComponent("" + countyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildings(<any>response_);
                } catch (e) {
                    return <Observable<BuildingDto[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<BuildingDto[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildings(response: HttpResponseBase): Observable<BuildingDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BuildingDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuildingDto[] | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiBuildingBuildingDetailClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getBuildingDetail(buildingId: string): Observable<BuildingDetailDto | null> {
        let url_ = this.baseUrl + "/api/Building/buildingDetail/{buildingId}";
        if (buildingId === undefined || buildingId === null)
            throw new Error("The parameter 'buildingId' must be defined.");
        url_ = url_.replace("{buildingId}", encodeURIComponent("" + buildingId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildingDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildingDetail(<any>response_);
                } catch (e) {
                    return <Observable<BuildingDetailDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<BuildingDetailDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildingDetail(response: HttpResponseBase): Observable<BuildingDetailDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BuildingDetailDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuildingDetailDto | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiBuildingBuildingNextLevelDetailClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getNextLevelDetail(buildingId: string): Observable<BuildingNextLevelDto | null> {
        let url_ = this.baseUrl + "/api/Building/buildingNextLevelDetail/{buildingId}";
        if (buildingId === undefined || buildingId === null)
            throw new Error("The parameter 'buildingId' must be defined.");
        url_ = url_.replace("{buildingId}", encodeURIComponent("" + buildingId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextLevelDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextLevelDetail(<any>response_);
                } catch (e) {
                    return <Observable<BuildingNextLevelDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<BuildingNextLevelDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextLevelDetail(response: HttpResponseBase): Observable<BuildingNextLevelDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BuildingNextLevelDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuildingNextLevelDto | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiBuildingClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    developBuilding(buildingId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Building";
        if (buildingId === undefined || buildingId === null)
            throw new Error("The parameter 'buildingId' must be defined.");
        url_ = url_.replace("{buildingId}", encodeURIComponent("" + buildingId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDevelopBuilding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDevelopBuilding(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDevelopBuilding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiGameNewRoundClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    newRound(): Observable<void> {
        let url_ = this.baseUrl + "/api/Game/newRound";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRound(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRound(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNewRound(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiGameMainPageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getMainPage(kingdomId: string): Observable<MainPageDto | null> {
        let url_ = this.baseUrl + "/api/Game/mainPage/{kingdomId}";
        if (kingdomId === undefined || kingdomId === null)
            throw new Error("The parameter 'kingdomId' must be defined.");
        url_ = url_.replace("{kingdomId}", encodeURIComponent("" + kingdomId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMainPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMainPage(<any>response_);
                } catch (e) {
                    return <Observable<MainPageDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<MainPageDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetMainPage(response: HttpResponseBase): Observable<MainPageDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MainPageDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainPageDto | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiTechnologyTechnologiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getTechnologies(kingdomId: string): Observable<TechnologyDto[] | null> {
        let url_ = this.baseUrl + "/api/Technology/technologies/{kingdomId}";
        if (kingdomId === undefined || kingdomId === null)
            throw new Error("The parameter 'kingdomId' must be defined.");
        url_ = url_.replace("{kingdomId}", encodeURIComponent("" + kingdomId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTechnologies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTechnologies(<any>response_);
                } catch (e) {
                    return <Observable<TechnologyDto[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<TechnologyDto[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetTechnologies(response: HttpResponseBase): Observable<TechnologyDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TechnologyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TechnologyDto[] | null>(<any>null);
    }

    getTechnologyDetail(technologyId: string): Observable<TechnologyDetailDto | null> {
        let url_ = this.baseUrl + "/api/Technology/technologies/{technologyId}";
        if (technologyId === undefined || technologyId === null)
            throw new Error("The parameter 'technologyId' must be defined.");
        url_ = url_.replace("{technologyId}", encodeURIComponent("" + technologyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTechnologyDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTechnologyDetail(<any>response_);
                } catch (e) {
                    return <Observable<TechnologyDetailDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<TechnologyDetailDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetTechnologyDetail(response: HttpResponseBase): Observable<TechnologyDetailDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TechnologyDetailDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TechnologyDetailDto | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiTechnologyDevelopClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    developTechnology(technologyId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Technology/develop/{technologyId}";
        if (technologyId === undefined || technologyId === null)
            throw new Error("The parameter 'technologyId' must be defined.");
        url_ = url_.replace("{technologyId}", encodeURIComponent("" + technologyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDevelopTechnology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDevelopTechnology(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDevelopTechnology(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiUnitUnitsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getUnits(countyId: string): Observable<UnitDto[] | null> {
        let url_ = this.baseUrl + "/api/Unit/units/{countyId}";
        if (countyId === undefined || countyId === null)
            throw new Error("The parameter 'countyId' must be defined.");
        url_ = url_.replace("{countyId}", encodeURIComponent("" + countyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnits(<any>response_);
                } catch (e) {
                    return <Observable<UnitDto[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitDto[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnits(response: HttpResponseBase): Observable<UnitDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UnitDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitDto[] | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiUnitUnitDetailsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getUnitDetails(unitSpecificsId: string, currentLvl: number): Observable<UnitDetailsDto | null> {
        let url_ = this.baseUrl + "/api/Unit/unitDetails/{unitSpecificsId}?";
        if (unitSpecificsId === undefined || unitSpecificsId === null)
            throw new Error("The parameter 'unitSpecificsId' must be defined.");
        url_ = url_.replace("{unitSpecificsId}", encodeURIComponent("" + unitSpecificsId)); 
        if (currentLvl === undefined || currentLvl === null)
            throw new Error("The parameter 'currentLvl' must be defined and cannot be null.");
        else
            url_ += "currentLvl=" + encodeURIComponent("" + currentLvl) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitDetails(<any>response_);
                } catch (e) {
                    return <Observable<UnitDetailsDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitDetailsDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitDetails(response: HttpResponseBase): Observable<UnitDetailsDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitDetailsDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitDetailsDto | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiUnitUnitNextLevelDetailsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getNextLevelDetail(unitSpecificsId: string, currentLvl: number): Observable<UnitNextLevelDto | null> {
        let url_ = this.baseUrl + "/api/Unit/unitNextLevelDetails/{unitSpecificsId}?";
        if (unitSpecificsId === undefined || unitSpecificsId === null)
            throw new Error("The parameter 'unitSpecificsId' must be defined.");
        url_ = url_.replace("{unitSpecificsId}", encodeURIComponent("" + unitSpecificsId)); 
        if (currentLvl === undefined || currentLvl === null)
            throw new Error("The parameter 'currentLvl' must be defined and cannot be null.");
        else
            url_ += "currentLvl=" + encodeURIComponent("" + currentLvl) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextLevelDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextLevelDetail(<any>response_);
                } catch (e) {
                    return <Observable<UnitNextLevelDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitNextLevelDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextLevelDetail(response: HttpResponseBase): Observable<UnitNextLevelDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitNextLevelDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitNextLevelDto | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiUnitRemoveClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    removeUnits(countyId: string, unitSpecificsId: string, lvl: number, count: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Unit/remove/{countyId}/{unitSpecificsId}?";
        if (countyId === undefined || countyId === null)
            throw new Error("The parameter 'countyId' must be defined.");
        url_ = url_.replace("{countyId}", encodeURIComponent("" + countyId)); 
        if (unitSpecificsId === undefined || unitSpecificsId === null)
            throw new Error("The parameter 'unitSpecificsId' must be defined.");
        url_ = url_.replace("{unitSpecificsId}", encodeURIComponent("" + unitSpecificsId)); 
        if (lvl === undefined || lvl === null)
            throw new Error("The parameter 'lvl' must be defined and cannot be null.");
        else
            url_ += "lvl=" + encodeURIComponent("" + lvl) + "&"; 
        if (count === undefined || count === null)
            throw new Error("The parameter 'count' must be defined and cannot be null.");
        else
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUnits(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUnits(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiUnitDevelopClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    developUnits(countyId: string, unitSpecificsId: string, currentLvl: number, count: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Unit/develop/{countyId}/{unitSpecificsId}?";
        if (countyId === undefined || countyId === null)
            throw new Error("The parameter 'countyId' must be defined.");
        url_ = url_.replace("{countyId}", encodeURIComponent("" + countyId)); 
        if (unitSpecificsId === undefined || unitSpecificsId === null)
            throw new Error("The parameter 'unitSpecificsId' must be defined.");
        url_ = url_.replace("{unitSpecificsId}", encodeURIComponent("" + unitSpecificsId)); 
        if (currentLvl === undefined || currentLvl === null)
            throw new Error("The parameter 'currentLvl' must be defined and cannot be null.");
        else
            url_ += "currentLvl=" + encodeURIComponent("" + currentLvl) + "&"; 
        if (count === undefined || count === null)
            throw new Error("The parameter 'count' must be defined and cannot be null.");
        else
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDevelopUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDevelopUnits(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDevelopUnits(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiUnitHireClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    hireUnits(countyId: string, unitSpecificsId: string, count: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Unit/hire/{countyId}/{unitSpecificsId}?";
        if (countyId === undefined || countyId === null)
            throw new Error("The parameter 'countyId' must be defined.");
        url_ = url_.replace("{countyId}", encodeURIComponent("" + countyId)); 
        if (unitSpecificsId === undefined || unitSpecificsId === null)
            throw new Error("The parameter 'unitSpecificsId' must be defined.");
        url_ = url_.replace("{unitSpecificsId}", encodeURIComponent("" + unitSpecificsId)); 
        if (count === undefined || count === null)
            throw new Error("The parameter 'count' must be defined and cannot be null.");
        else
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHireUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHireUnits(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHireUnits(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiUserUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getUsers(pageNumber: number | null | undefined, pageSize: number | null | undefined): Observable<PagedListDtoOfUserDto | null> {
        let url_ = this.baseUrl + "/api/User/users?";
        if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedListDtoOfUserDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListDtoOfUserDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedListDtoOfUserDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListDtoOfUserDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListDtoOfUserDto | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiUserFilteredUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getFilteredUsers(name: string | null | undefined, minScore: number | null | undefined, maxScore: number | null | undefined, pageNumber: number | null | undefined, pageSize: number | null | undefined): Observable<PagedListDtoOfUserDto | null> {
        let url_ = this.baseUrl + "/api/User/filteredUsers?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (minScore !== undefined)
            url_ += "minScore=" + encodeURIComponent("" + minScore) + "&"; 
        if (maxScore !== undefined)
            url_ += "maxScore=" + encodeURIComponent("" + maxScore) + "&"; 
        if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilteredUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilteredUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedListDtoOfUserDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListDtoOfUserDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetFilteredUsers(response: HttpResponseBase): Observable<PagedListDtoOfUserDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedListDtoOfUserDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListDtoOfUserDto | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getUser(id: string): Observable<UserDto | null> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<UserDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto | null>(<any>null);
    }

    deleteUser(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiUserNewUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    createUser(userCreateDto: UserCreateDto | null): Observable<UserDto | null> {
        let url_ = this.baseUrl + "/api/User/newUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userCreateDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDto | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto | null>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<UserDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto | null>(<any>null);
    }
}

export class TokenDto implements ITokenDto {
    accessToken?: string | undefined;

    constructor(data?: ITokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
        }
    }

    static fromJS(data: any): TokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        return data; 
    }
}

export interface ITokenDto {
    accessToken?: string | undefined;
}

export class LoginDto implements ILoginDto {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginDto {
    userName?: string | undefined;
    password?: string | undefined;
}

export class RegisterDto implements IRegisterDto {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface IRegisterDto {
    userName?: string | undefined;
    password?: string | undefined;
}

export class BuildingDto implements IBuildingDto {
    id!: string;
    level!: number;
    name?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    maxLevel!: number;
    status!: BuildingStatus;

    constructor(data?: IBuildingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.level = data["level"];
            this.name = data["name"];
            this.description = data["description"];
            this.imageUrl = data["imageUrl"];
            this.maxLevel = data["maxLevel"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): BuildingDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["level"] = this.level;
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["maxLevel"] = this.maxLevel;
        data["status"] = this.status;
        return data; 
    }
}

export interface IBuildingDto {
    id: string;
    level: number;
    name?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    maxLevel: number;
    status: BuildingStatus;
}

export enum BuildingStatus {
    Built = 1, 
    NotBuilt = 2, 
}

export class BuildingDetailDto implements IBuildingDetailDto {
    id!: string;
    level!: number;
    name?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    maxLevel!: number;
    populationBonus!: number;
    forceLimitBonus!: number;
    woodProduction!: number;
    marbleProduction!: number;
    wineProduction!: number;
    sulfurProduction!: number;
    researchOutPut!: number;
    woodCost!: number;
    marbleCost!: number;
    wineCost!: number;
    sulfurCost!: number;
    goldCost!: number;
    status!: BuildingStatus;

    constructor(data?: IBuildingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.level = data["level"];
            this.name = data["name"];
            this.description = data["description"];
            this.imageUrl = data["imageUrl"];
            this.maxLevel = data["maxLevel"];
            this.populationBonus = data["populationBonus"];
            this.forceLimitBonus = data["forceLimitBonus"];
            this.woodProduction = data["woodProduction"];
            this.marbleProduction = data["marbleProduction"];
            this.wineProduction = data["wineProduction"];
            this.sulfurProduction = data["sulfurProduction"];
            this.researchOutPut = data["researchOutPut"];
            this.woodCost = data["woodCost"];
            this.marbleCost = data["marbleCost"];
            this.wineCost = data["wineCost"];
            this.sulfurCost = data["sulfurCost"];
            this.goldCost = data["goldCost"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): BuildingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["level"] = this.level;
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["maxLevel"] = this.maxLevel;
        data["populationBonus"] = this.populationBonus;
        data["forceLimitBonus"] = this.forceLimitBonus;
        data["woodProduction"] = this.woodProduction;
        data["marbleProduction"] = this.marbleProduction;
        data["wineProduction"] = this.wineProduction;
        data["sulfurProduction"] = this.sulfurProduction;
        data["researchOutPut"] = this.researchOutPut;
        data["woodCost"] = this.woodCost;
        data["marbleCost"] = this.marbleCost;
        data["wineCost"] = this.wineCost;
        data["sulfurCost"] = this.sulfurCost;
        data["goldCost"] = this.goldCost;
        data["status"] = this.status;
        return data; 
    }
}

export interface IBuildingDetailDto {
    id: string;
    level: number;
    name?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    maxLevel: number;
    populationBonus: number;
    forceLimitBonus: number;
    woodProduction: number;
    marbleProduction: number;
    wineProduction: number;
    sulfurProduction: number;
    researchOutPut: number;
    woodCost: number;
    marbleCost: number;
    wineCost: number;
    sulfurCost: number;
    goldCost: number;
    status: BuildingStatus;
}

export class BuildingNextLevelDto implements IBuildingNextLevelDto {
    level!: number;
    populationBonus!: number;
    forceLimitBonus!: number;
    woodProduction!: number;
    marbleProduction!: number;
    wineProduction!: number;
    sulfurProduction!: number;
    researchOutPut!: number;
    woodCost!: number;
    marbleCost!: number;
    wineCost!: number;
    sulfurCost!: number;
    goldCost!: number;

    constructor(data?: IBuildingNextLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.populationBonus = data["populationBonus"];
            this.forceLimitBonus = data["forceLimitBonus"];
            this.woodProduction = data["woodProduction"];
            this.marbleProduction = data["marbleProduction"];
            this.wineProduction = data["wineProduction"];
            this.sulfurProduction = data["sulfurProduction"];
            this.researchOutPut = data["researchOutPut"];
            this.woodCost = data["woodCost"];
            this.marbleCost = data["marbleCost"];
            this.wineCost = data["wineCost"];
            this.sulfurCost = data["sulfurCost"];
            this.goldCost = data["goldCost"];
        }
    }

    static fromJS(data: any): BuildingNextLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingNextLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["populationBonus"] = this.populationBonus;
        data["forceLimitBonus"] = this.forceLimitBonus;
        data["woodProduction"] = this.woodProduction;
        data["marbleProduction"] = this.marbleProduction;
        data["wineProduction"] = this.wineProduction;
        data["sulfurProduction"] = this.sulfurProduction;
        data["researchOutPut"] = this.researchOutPut;
        data["woodCost"] = this.woodCost;
        data["marbleCost"] = this.marbleCost;
        data["wineCost"] = this.wineCost;
        data["sulfurCost"] = this.sulfurCost;
        data["goldCost"] = this.goldCost;
        return data; 
    }
}

export interface IBuildingNextLevelDto {
    level: number;
    populationBonus: number;
    forceLimitBonus: number;
    woodProduction: number;
    marbleProduction: number;
    wineProduction: number;
    sulfurProduction: number;
    researchOutPut: number;
    woodCost: number;
    marbleCost: number;
    wineCost: number;
    sulfurCost: number;
    goldCost: number;
}

export class MainPageDto implements IMainPageDto {
    round!: number;
    gold!: number;
    goldIncome!: number;
    goldIncomeBonus!: number;
    researchPoint!: number;
    researchOutput!: number;
    researchOutputBonus!: number;
    wood!: number;
    woodProduction!: number;
    woodProductionBonus!: number;
    marble!: number;
    marbleProduction!: number;
    marbleProductionBonus!: number;
    wine!: number;
    wineProduction!: number;
    wineProductionBonus!: number;
    sulfur!: number;
    sulfurProduction!: number;
    sulfurProductionBonus!: number;
    usedForceLimit!: number;
    maxForceLimit!: number;
    buildings?: BuildingViewDto[] | undefined;

    constructor(data?: IMainPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.round = data["round"];
            this.gold = data["gold"];
            this.goldIncome = data["goldIncome"];
            this.goldIncomeBonus = data["goldIncomeBonus"];
            this.researchPoint = data["researchPoint"];
            this.researchOutput = data["researchOutput"];
            this.researchOutputBonus = data["researchOutputBonus"];
            this.wood = data["wood"];
            this.woodProduction = data["woodProduction"];
            this.woodProductionBonus = data["woodProductionBonus"];
            this.marble = data["marble"];
            this.marbleProduction = data["marbleProduction"];
            this.marbleProductionBonus = data["marbleProductionBonus"];
            this.wine = data["wine"];
            this.wineProduction = data["wineProduction"];
            this.wineProductionBonus = data["wineProductionBonus"];
            this.sulfur = data["sulfur"];
            this.sulfurProduction = data["sulfurProduction"];
            this.sulfurProductionBonus = data["sulfurProductionBonus"];
            this.usedForceLimit = data["usedForceLimit"];
            this.maxForceLimit = data["maxForceLimit"];
            if (data["buildings"] && data["buildings"].constructor === Array) {
                this.buildings = [];
                for (let item of data["buildings"])
                    this.buildings.push(BuildingViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MainPageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainPageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["round"] = this.round;
        data["gold"] = this.gold;
        data["goldIncome"] = this.goldIncome;
        data["goldIncomeBonus"] = this.goldIncomeBonus;
        data["researchPoint"] = this.researchPoint;
        data["researchOutput"] = this.researchOutput;
        data["researchOutputBonus"] = this.researchOutputBonus;
        data["wood"] = this.wood;
        data["woodProduction"] = this.woodProduction;
        data["woodProductionBonus"] = this.woodProductionBonus;
        data["marble"] = this.marble;
        data["marbleProduction"] = this.marbleProduction;
        data["marbleProductionBonus"] = this.marbleProductionBonus;
        data["wine"] = this.wine;
        data["wineProduction"] = this.wineProduction;
        data["wineProductionBonus"] = this.wineProductionBonus;
        data["sulfur"] = this.sulfur;
        data["sulfurProduction"] = this.sulfurProduction;
        data["sulfurProductionBonus"] = this.sulfurProductionBonus;
        data["usedForceLimit"] = this.usedForceLimit;
        data["maxForceLimit"] = this.maxForceLimit;
        if (this.buildings && this.buildings.constructor === Array) {
            data["buildings"] = [];
            for (let item of this.buildings)
                data["buildings"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMainPageDto {
    round: number;
    gold: number;
    goldIncome: number;
    goldIncomeBonus: number;
    researchPoint: number;
    researchOutput: number;
    researchOutputBonus: number;
    wood: number;
    woodProduction: number;
    woodProductionBonus: number;
    marble: number;
    marbleProduction: number;
    marbleProductionBonus: number;
    wine: number;
    wineProduction: number;
    wineProductionBonus: number;
    sulfur: number;
    sulfurProduction: number;
    sulfurProductionBonus: number;
    usedForceLimit: number;
    maxForceLimit: number;
    buildings?: BuildingViewDto[] | undefined;
}

export class BuildingViewDto implements IBuildingViewDto {
    id!: string;
    imageUrl?: string | undefined;
    status!: BuildingStatus;

    constructor(data?: IBuildingViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.imageUrl = data["imageUrl"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): BuildingViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imageUrl"] = this.imageUrl;
        data["status"] = this.status;
        return data; 
    }
}

export interface IBuildingViewDto {
    id: string;
    imageUrl?: string | undefined;
    status: BuildingStatus;
}

export class TechnologyDto implements ITechnologyDto {
    id!: string;
    name?: string | undefined;
    description?: string | undefined;
    pictureUrl?: string | undefined;
    researchPointCost!: number;
    status!: ResearchStatus;

    constructor(data?: ITechnologyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.pictureUrl = data["pictureUrl"];
            this.researchPointCost = data["researchPointCost"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): TechnologyDto {
        data = typeof data === 'object' ? data : {};
        let result = new TechnologyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["pictureUrl"] = this.pictureUrl;
        data["researchPointCost"] = this.researchPointCost;
        data["status"] = this.status;
        return data; 
    }
}

export interface ITechnologyDto {
    id: string;
    name?: string | undefined;
    description?: string | undefined;
    pictureUrl?: string | undefined;
    researchPointCost: number;
    status: ResearchStatus;
}

export enum ResearchStatus {
    Researched = 1, 
    UnResearched = 2, 
}

export class TechnologyDetailDto implements ITechnologyDetailDto {
    id!: string;
    name?: string | undefined;
    description?: string | undefined;
    pictureUrl?: string | undefined;
    woodBonus!: number;
    stoneBonus!: number;
    wineBonus!: number;
    sulfurBonus!: number;
    goldBonus!: number;
    researchBonus!: number;
    attackPowerBonus!: number;
    defensePowerBonus!: number;
    status!: ResearchStatus;

    constructor(data?: ITechnologyDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.pictureUrl = data["pictureUrl"];
            this.woodBonus = data["woodBonus"];
            this.stoneBonus = data["stoneBonus"];
            this.wineBonus = data["wineBonus"];
            this.sulfurBonus = data["sulfurBonus"];
            this.goldBonus = data["goldBonus"];
            this.researchBonus = data["researchBonus"];
            this.attackPowerBonus = data["attackPowerBonus"];
            this.defensePowerBonus = data["defensePowerBonus"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): TechnologyDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new TechnologyDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["pictureUrl"] = this.pictureUrl;
        data["woodBonus"] = this.woodBonus;
        data["stoneBonus"] = this.stoneBonus;
        data["wineBonus"] = this.wineBonus;
        data["sulfurBonus"] = this.sulfurBonus;
        data["goldBonus"] = this.goldBonus;
        data["researchBonus"] = this.researchBonus;
        data["attackPowerBonus"] = this.attackPowerBonus;
        data["defensePowerBonus"] = this.defensePowerBonus;
        data["status"] = this.status;
        return data; 
    }
}

export interface ITechnologyDetailDto {
    id: string;
    name?: string | undefined;
    description?: string | undefined;
    pictureUrl?: string | undefined;
    woodBonus: number;
    stoneBonus: number;
    wineBonus: number;
    sulfurBonus: number;
    goldBonus: number;
    researchBonus: number;
    attackPowerBonus: number;
    defensePowerBonus: number;
    status: ResearchStatus;
}

export class UnitDto implements IUnitDto {
    unitSpecificsId!: string;
    name?: string | undefined;
    count!: number;
    level!: number;
    maxLevel!: number;
    imageUrl?: string | undefined;

    constructor(data?: IUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unitSpecificsId = data["unitSpecificsId"];
            this.name = data["name"];
            this.count = data["count"];
            this.level = data["level"];
            this.maxLevel = data["maxLevel"];
            this.imageUrl = data["imageUrl"];
        }
    }

    static fromJS(data: any): UnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitSpecificsId"] = this.unitSpecificsId;
        data["name"] = this.name;
        data["count"] = this.count;
        data["level"] = this.level;
        data["maxLevel"] = this.maxLevel;
        data["imageUrl"] = this.imageUrl;
        return data; 
    }
}

export interface IUnitDto {
    unitSpecificsId: string;
    name?: string | undefined;
    count: number;
    level: number;
    maxLevel: number;
    imageUrl?: string | undefined;
}

export class UnitDetailsDto implements IUnitDetailsDto {
    unitSpecificsId!: string;
    level!: number;
    maxLevel!: number;
    name?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    rangedAttackPower!: number;
    rangedDefensePower!: number;
    meleeAttackPower!: number;
    meleeDefensePower!: number;
    forceLimit!: number;
    woodCost!: number;
    marbleCost!: number;
    wineCost!: number;
    sulfurCost!: number;
    goldCost!: number;
    woodUpkeep!: number;
    marbleUpkeep!: number;
    wineUpkeep!: number;
    sulfurUpkeep!: number;
    goldUpkeep!: number;

    constructor(data?: IUnitDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unitSpecificsId = data["unitSpecificsId"];
            this.level = data["level"];
            this.maxLevel = data["maxLevel"];
            this.name = data["name"];
            this.description = data["description"];
            this.imageUrl = data["imageUrl"];
            this.rangedAttackPower = data["rangedAttackPower"];
            this.rangedDefensePower = data["rangedDefensePower"];
            this.meleeAttackPower = data["meleeAttackPower"];
            this.meleeDefensePower = data["meleeDefensePower"];
            this.forceLimit = data["forceLimit"];
            this.woodCost = data["woodCost"];
            this.marbleCost = data["marbleCost"];
            this.wineCost = data["wineCost"];
            this.sulfurCost = data["sulfurCost"];
            this.goldCost = data["goldCost"];
            this.woodUpkeep = data["woodUpkeep"];
            this.marbleUpkeep = data["marbleUpkeep"];
            this.wineUpkeep = data["wineUpkeep"];
            this.sulfurUpkeep = data["sulfurUpkeep"];
            this.goldUpkeep = data["goldUpkeep"];
        }
    }

    static fromJS(data: any): UnitDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitSpecificsId"] = this.unitSpecificsId;
        data["level"] = this.level;
        data["maxLevel"] = this.maxLevel;
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["rangedAttackPower"] = this.rangedAttackPower;
        data["rangedDefensePower"] = this.rangedDefensePower;
        data["meleeAttackPower"] = this.meleeAttackPower;
        data["meleeDefensePower"] = this.meleeDefensePower;
        data["forceLimit"] = this.forceLimit;
        data["woodCost"] = this.woodCost;
        data["marbleCost"] = this.marbleCost;
        data["wineCost"] = this.wineCost;
        data["sulfurCost"] = this.sulfurCost;
        data["goldCost"] = this.goldCost;
        data["woodUpkeep"] = this.woodUpkeep;
        data["marbleUpkeep"] = this.marbleUpkeep;
        data["wineUpkeep"] = this.wineUpkeep;
        data["sulfurUpkeep"] = this.sulfurUpkeep;
        data["goldUpkeep"] = this.goldUpkeep;
        return data; 
    }
}

export interface IUnitDetailsDto {
    unitSpecificsId: string;
    level: number;
    maxLevel: number;
    name?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    rangedAttackPower: number;
    rangedDefensePower: number;
    meleeAttackPower: number;
    meleeDefensePower: number;
    forceLimit: number;
    woodCost: number;
    marbleCost: number;
    wineCost: number;
    sulfurCost: number;
    goldCost: number;
    woodUpkeep: number;
    marbleUpkeep: number;
    wineUpkeep: number;
    sulfurUpkeep: number;
    goldUpkeep: number;
}

export class UnitNextLevelDto implements IUnitNextLevelDto {
    unitSpecificsId!: string;
    level!: number;
    name?: string | undefined;
    imageUrl?: string | undefined;
    rangedAttackPower!: number;
    rangedDefensePower!: number;
    meleeAttackPower!: number;
    meleeDefensePower!: number;
    forceLimit!: number;
    woodCost!: number;
    marbleCost!: number;
    wineCost!: number;
    sulfurCost!: number;
    goldCost!: number;
    woodUpkeep!: number;
    marbleUpkeep!: number;
    wineUpkeep!: number;
    sulfurUpkeep!: number;
    goldUpkeep!: number;

    constructor(data?: IUnitNextLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unitSpecificsId = data["unitSpecificsId"];
            this.level = data["level"];
            this.name = data["name"];
            this.imageUrl = data["imageUrl"];
            this.rangedAttackPower = data["rangedAttackPower"];
            this.rangedDefensePower = data["rangedDefensePower"];
            this.meleeAttackPower = data["meleeAttackPower"];
            this.meleeDefensePower = data["meleeDefensePower"];
            this.forceLimit = data["forceLimit"];
            this.woodCost = data["woodCost"];
            this.marbleCost = data["marbleCost"];
            this.wineCost = data["wineCost"];
            this.sulfurCost = data["sulfurCost"];
            this.goldCost = data["goldCost"];
            this.woodUpkeep = data["woodUpkeep"];
            this.marbleUpkeep = data["marbleUpkeep"];
            this.wineUpkeep = data["wineUpkeep"];
            this.sulfurUpkeep = data["sulfurUpkeep"];
            this.goldUpkeep = data["goldUpkeep"];
        }
    }

    static fromJS(data: any): UnitNextLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitNextLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitSpecificsId"] = this.unitSpecificsId;
        data["level"] = this.level;
        data["name"] = this.name;
        data["imageUrl"] = this.imageUrl;
        data["rangedAttackPower"] = this.rangedAttackPower;
        data["rangedDefensePower"] = this.rangedDefensePower;
        data["meleeAttackPower"] = this.meleeAttackPower;
        data["meleeDefensePower"] = this.meleeDefensePower;
        data["forceLimit"] = this.forceLimit;
        data["woodCost"] = this.woodCost;
        data["marbleCost"] = this.marbleCost;
        data["wineCost"] = this.wineCost;
        data["sulfurCost"] = this.sulfurCost;
        data["goldCost"] = this.goldCost;
        data["woodUpkeep"] = this.woodUpkeep;
        data["marbleUpkeep"] = this.marbleUpkeep;
        data["wineUpkeep"] = this.wineUpkeep;
        data["sulfurUpkeep"] = this.sulfurUpkeep;
        data["goldUpkeep"] = this.goldUpkeep;
        return data; 
    }
}

export interface IUnitNextLevelDto {
    unitSpecificsId: string;
    level: number;
    name?: string | undefined;
    imageUrl?: string | undefined;
    rangedAttackPower: number;
    rangedDefensePower: number;
    meleeAttackPower: number;
    meleeDefensePower: number;
    forceLimit: number;
    woodCost: number;
    marbleCost: number;
    wineCost: number;
    sulfurCost: number;
    goldCost: number;
    woodUpkeep: number;
    marbleUpkeep: number;
    wineUpkeep: number;
    sulfurUpkeep: number;
    goldUpkeep: number;
}

export class PagedListDtoOfUserDto implements IPagedListDtoOfUserDto {
    items?: UserDto[] | undefined;
    paginationHeader?: PaginationHeader | undefined;

    constructor(data?: IPagedListDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
            this.paginationHeader = data["paginationHeader"] ? PaginationHeader.fromJS(data["paginationHeader"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["paginationHeader"] = this.paginationHeader ? this.paginationHeader.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPagedListDtoOfUserDto {
    items?: UserDto[] | undefined;
    paginationHeader?: PaginationHeader | undefined;
}

export class UserDto implements IUserDto {
    id?: string | undefined;
    userName?: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IUserDto {
    id?: string | undefined;
    userName?: string | undefined;
}

export class PaginationHeader implements IPaginationHeader {
    totalCount!: number;
    pageSize!: number;
    currentPage!: number;
    totalPages!: number;
    hasNext!: boolean;
    hasPrevious!: boolean;

    constructor(data?: IPaginationHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            this.pageSize = data["pageSize"];
            this.currentPage = data["currentPage"];
            this.totalPages = data["totalPages"];
            this.hasNext = data["hasNext"];
            this.hasPrevious = data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginationHeader {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data; 
    }
}

export interface IPaginationHeader {
    totalCount: number;
    pageSize: number;
    currentPage: number;
    totalPages: number;
    hasNext: boolean;
    hasPrevious: boolean;
}

export class UserCreateDto implements IUserCreateDto {
    username?: string | undefined;
    password?: string | undefined;

    constructor(data?: IUserCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): UserCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface IUserCreateDto {
    username?: string | undefined;
    password?: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}